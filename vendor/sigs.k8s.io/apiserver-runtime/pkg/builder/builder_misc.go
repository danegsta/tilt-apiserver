package builder

import (
	"k8s.io/apimachinery/pkg/runtime"
	openapicommon "k8s.io/kube-openapi/pkg/common"
	"sigs.k8s.io/apiserver-runtime/internal/sample-apiserver/pkg/cmd/server"
)

// WithOpenAPIDefinitions registers resource OpenAPI definitions generated by openapi-gen.
//
//    export K8sAPIS=k8s.io/apimachinery/pkg/api/resource,\
//      k8s.io/apimachinery/pkg/apis/meta/v1,\
//      k8s.io/apimachinery/pkg/runtime,\
//      k8s.io/apimachinery/pkg/version
//    export MY_APIS=my-go-pkg/pkg/apis/my-group/my-version
//    export OPENAPI=my-go-pkg/pkg/generated/openapi
//    openapi-gen --input-dirs $K8SAPIS,$MY_APIS --output-package $OPENAPI \
//      -O zz_generated.openapi --output-base ../../.. --go-header-file ./hack/boilerplate.go.txt
func (a *Server) WithOpenAPIDefinitions(
	name, version string, openAPI openapicommon.GetOpenAPIDefinitions) *Server {
	server.SetOpenAPIDefinitions(name, version, openAPI)
	return a
}

// WithAdditionalSchemeInstallers registers functions to install additional functions or resources into the Scheme.
// This can be used to manually registering defaulting functions, conversion functions, or resource types, rather
// than registering them automatically by implementing the corresponding interfaces on the resources.
func (a *Server) WithAdditionalSchemeInstallers(fns ...func(*runtime.Scheme) error) *Server {
	a.schemeBuilder.Register(fns...)
	return a
}

// WithAdditionalSchemesToBuild will add types and functions to these Schemes in addition to the
// apiserver.Scheme.
// This can be used to register the resource types, defaulting functions, and conversion functions
// with additional Scheme's.
func (a *Server) WithAdditionalSchemesToBuild(s ...*runtime.Scheme) *Server {
	a.schemes = append(a.schemes, s...)
	return a
}
